package com.jrdm.exploit;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

import org.apache.log4j.Logger;

import com.jrdm.common.MyConstants;
import com.jrdm.common.Utility;
import com.jrdm.model.BaseMetrics;
import com.jrdm.model.Cvss;

public final class CvssService {
	
	final static Logger logger = Logger.getLogger(CvssService.class);
	
	/*public static void main(String[] args) throws Exception {
		logger.debug("-----Calculate-----");
		
		//String[] cvssStr = new String[]{"AV:N/AC:L/Au:N/C:P/I:N/A:N","AV:N/AC:H/Au:N/C:N/I:P/A:N"};
		//String[] cvssStr = new String[]{"AV:N/AC:L/Au:N/C:P/I:N/A:N"};
		
		String[] cvssStr = new String[]{"AV:N/AC:L/Au:N/C:N/I:N/A:C","AV:N/AC:L/Au:N/C:C/I:C/A:C","AV:L/AC:H/Au:N/C:C/I:C/A:C"};
		
		CvssService calc = new CvssService();
		
		for(String vector: cvssStr){
			Cvss cvss = new Cvss();
			cvss.setVector(vector);
			calc.calculate(cvss);
			
		//	logger.debug("calc=>" + cvss.toString());
		}
		
		
	}*/
	
	private Properties prop = new Properties();
	private List<Cvss> configList = new ArrayList<Cvss>();
	
	public CvssService(){
	    getConfig();
	}

	private void getConfig(){
		try {
			InputStream in = getClass().getResourceAsStream(MyConstants.PROP_CVSS_FILE);
			prop.load(in);

			String startStr = prop.getProperty("cvss.start");//3
			String endStr = prop.getProperty("cvss.end");//5
			String defaultScore = prop.getProperty("cvss.no_vector");//10.0

			int start = Integer.valueOf( startStr );
			int end = Integer.valueOf( endStr );

			//iterate from start - end for the ranking based on scores
			for(int i = start ; i <= end ; i++)
			{
				String rank = String.valueOf(String.valueOf(i)); //3
				String rangeStr = prop.getProperty(rank); //3=0.0-3.9
				String rankDesc = prop.getProperty("cvss." + rank);//LOW

				if( Utility.isNotNullEmpty(rangeStr) ){
					Cvss cvss = new Cvss();
					cvss.setRankDescription(rankDesc);
					cvss.setRank(i);
					cvss.setNoVectorScore(Double.parseDouble( defaultScore) );

					//get the range
					String[] range = rangeStr.split("-");
					cvss.setScoreFrom( Math.round(Double.parseDouble(range[0]) * 100.0) / 100.0 );
					cvss.setScoreTo( Math.round(Double.parseDouble(range[1]) * 100.0) / 100.0 );

					configList.add(cvss);
				}
			}//for-loop
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * 
	 * @param cvss
	 * @return
	 * 
	 * Sample: AV:N/AC:L/Au:N/C:P/I:N/A:N
	 * AV:N/AC:H/Au:N/C:N/I:P/A:N
	 */
	public final void calculate( Cvss cvss ){
		
		String vector = cvss.getVector();
		
		/**
		 * From NVD website,
		 * if a vendor provides no details about a vulnerability, 
		 * NVD will score that vulnerability as a 10.0 (the highest rating).
		 */
		double baseScore = 10.0;
		
		if (Utility.isNotNullEmpty(vector) ){
			BaseMetrics metrics = new BaseMetrics(vector);
			metrics.calculate(); 
			
			/* get values for computation */
			double accessVector = metrics.getAccessVectorScore();
			double accessComplexity = metrics.getAccessComplexityScore();
			double authentication = metrics.getAuthenticationScore();
			double confImpact = metrics.getConfidentialityScore();
			double integImpact = metrics. getIntegrityScore();
			double availImpact = metrics.getAvailabilityScore();
			
			/* Common Vulnerability Scoring System (v2) 
			 * BaseScore = round_to_1_decimal(((0.6*Impact)+(0.4*Exploitability)â€“1.5)*f(Impact))
			 * Impact = 10.41*(1-(1-ConfImpact)*(1-IntegImpact)*(1-AvailImpact))
			 * Exploitability = 20* AccessVector*AccessComplexity*Authentication
			 * f(impact)= 0 if Impact=0, 1.176 otherwise
			 * */
			double impact = 10.41*(1-(1-confImpact)*(1-integImpact)*(1-availImpact));
			double exploitability = 20*accessVector*accessComplexity*authentication;
			double fimpact = (impact == 0.0 ? 0 : 1.176);
			double computedScore = ( (0.6*impact) + (0.4*exploitability) - 1.50) * (fimpact) ;
			baseScore = Math.round(computedScore * 100.0) / 100.0;
			
			logger.debug("impact=" + String.valueOf(impact));
			logger.debug("exploitability=" + String.valueOf(exploitability));
			logger.debug("f_impact=" + String.valueOf(fimpact));
			logger.debug("computed score=" + String.valueOf(computedScore));
		}
		
		logger.debug("base score=" + String.valueOf(baseScore));
		
		//find the range
		/*
		 * 	3=0.0-3.9
			4=4.0-6.9
			5=7.0-10.0
		 */
		String rankDesc = "";
		int rank = 0;
		
		for(Cvss c : configList){
			if( baseScore > c.getScoreFrom() && baseScore < c.getScoreTo()){
				rank = c.getRank();
				rankDesc = c.getRankDescription();
				break;
			} else {
				if(baseScore == c.getScoreFrom() || baseScore == c.getScoreTo()){
					rank = c.getRank();
					rankDesc = c.getRankDescription();
					break;
				} 
			}
		}
		
		cvss.setScore(baseScore);
		cvss.setRankDescription(rankDesc);
		cvss.setRank(rank);
		
		logger.debug(cvss.toString());
		
	}
	
	/*private double roundTo1Decimal(double value){
		logger.debug("roundTo1Decimal=>" + Double.toString(value) + 
				" rounded=" + Double.toString(value) );
	}*/
	
	

	public Properties getProp() {
		return prop;
	}

	public void setProp(Properties prop) {
		this.prop = prop;
	}

	public List<Cvss> getConfigList() {
		return configList;
	}

	public void setConfigList(List<Cvss> configList) {
		this.configList = configList;
	}

}
